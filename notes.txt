
8/14:
Several different numbering schemes.

Local numbers are per-file and per version.  Of the form (hash-of-file, id)

Global numbers are what's displayed. They are sequential. 

When software is produced, can construct an explicit map. Can update the map when
new code is seen.


When a new version is released, construct a map from NewLocal to Global.
Can just keep both maps; hash+id should make it unique.

Properties:

- if a code file is unchanged, numbers will always stay constant
- gracefully handles code not seen statically; assigns it a number the first
time and if the number is cached, will be stable forever.



Can do same trick for C via library interposition
same trick for python via loader? Cite SEJITS

---
Paper:

Keep theme of "previous API, new API good"
Show how to practically carve out new API for legacy systems
Show how to handle version upgrades leveraging static analysis

Should demonstrate dynamic reconfiguration
Can flip between off, on, and summarize


--
Impl:
Need a thread to listen for config instructions
isEnabled table in log wrapper
save-restore for local to global mapping
--

8/22:

Listen thread is set. Table saving is set. Is enabled table is present.
Next steps:
	Slurping local-to-global mapping.
	Test script to show we can keep control of Hadoop classloading during MR job
	Performance microbenchmark
	Summarizing messages?

9/12:
Notes from Google talk
	Should lookup Frost logger	by	 carl de marken
	C is hard -- if statically linked, no library interposition.
	tag system and api aren't thought through yet	
	
9/13:
	Built microbenchmark.
Warmup made a big difference. JIT effect?
Raw Log4j no-log path is about 4ns
No-log path in my code is 44ns
Exit immediately with full code is 13 ns
Exit immediately with most of the if branches commented out drops to 3ns 

With short code but leaving in the dispatch table lookup is 29 ns

Two serious sourc

